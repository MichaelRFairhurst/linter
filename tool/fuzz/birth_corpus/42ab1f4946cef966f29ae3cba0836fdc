2017, the Dart project authors.  Please see the AUTHORS file
// for details. All rights reserved. Use of this source code is governed by a
// BSD-style license that can be found in the LICENSE file.

// Dart test for type checks on usage of expressions of type void.

void use(dynamic x) { }
void useAsVoid(void x) { }

Object testVoidParam(void x) {
  x;  //# param_stmt: ok
  true ? x : x;  //# param_conditional: ok
  for (x; false; x) {}   //# param_for: ok
  useAsVoid(x); //# param_argument_void: ok
  use(x);   //# param_argument: compile-time error
  use(x as Object);  //# param_as: ok
  void y = x;   //# param_void_init: ok
  dynamic z = x;  //# param_dynamic_init: compile-time error
  x is Object;   //# param_is: compile-time error
  throw x;   //# param_throw: compile-time error
  <void>[x];   //# param_literal_void_list_init: ok
  <Object>[x];   //# param_literal_list_init: compile-time error
  var m1 = <int, void>{4: x};   //# param_literal_map_value_init: ok
  var m2 = <void, int>{x : 4};   //# param_literal_map_key_init: ok
  var m3 = <dynamic, dynamic>{4: x};  //# param_literal_map_value_init2: compile-time error
  var m4 = <dynamic, dynamic>{x : 4};  //# param_literal_map_key_init2: compile-time error
  x ?? 499;  //# param_null_equals1: compile-time error
  null ?? x;  //# param_null_equals2: ok
  return x;   //# param_return: compile-time error
  while (x) {};  //# param_while: compile-time error
  do {} while (x);  //# param_do_while: compile-time error
  for (var v in x) {}   //# param_for_in: compile-time error
  for (x in [1, 2]) {}  //# param_for_in2: ok
  x += 1;  //# param_plus_eq: compile-time error
  x.toString();  //# param_toString: compile-time error
  x?.toString();  //# param_null_dot: compile-time error
  x..toString();  //# param_cascade: compile-time error
  if (x) {}; //# param_conditional_stmt: compile-time error
  !x; //# param_boolean_negation: compile-time error
  x && true; //# param_boolean_and_left: compile-time error
  true && x; //# param_boolean_and_right: compile-time error
  x || true; //# param_boolean_or_left: compile-time error
  true || x; //# param_boolean_or_right: compile-time error
  x == 3; //# param_equals_left: compile-time error
  3 == x; //# param_equals_right: compile-time error
  identical(3, x); //# param_identical: compile-time error
  3 + x; //# param_addition: compile-time error
  3 * x; //# param_multiplication: compile-time error
  -x; //# param_negation: compile-time error
  x(3); //# param_use_as_function: compile-time error
  "hello$x"; //# param_use_in_string_interpolation: compile-time error
  x ??= 3; //# param_use_in_conditional_assignment_left: compile-time error
  Object xx;  xx ??= x; //# param_use_in_conditional_assignment_right: compile-time error
  var ll = <int>[3]; ll[x]; //# param_use_in_list_subscript: compile-time error
  var mm = <void, void>{}; mm[x]; //# param_use_in_map_lookup: compile-time error
}

testVoidAsync(void x) async {
  await x; //# async_use_in_await: ok
}

testVoidAsyncStar(void x) async* {
  yield x; //# async_use_in_yield: compile-time error
  yield* x; //# async_use_in_yield_star: compile-time error
  await for (var i in x) {} //# async_use_in_await_for: compile-time error
}

testVoidSyncStar(void x) sync* {
  yield x; //# sync_use_in_yield: compile-time error
  yield* x; //# sync_use_in_yield_star: compile-time error
}

const void c = null;

dynamic testVoidDefaultParameter([int y = c]) {} //# void_default_parameter_global: compile-time error

dynamic testVoidDefaultParameterClosure() {
  ([int y = c]) => 3;//# void_default_parameter_closure: compile-time error
}

dynamic testVoidParamDynamic(void x) {
  return x;   //# param_return_dynamic: ok
}

Object testVoidCall(void f()) {
  f();  //# call_stmt: ok
  true ? f() : f();  //# call_conditional: ok
  for (f(); false; f()) {}   //# call_for: ok
  useAsVoid(f()); //# call_argument_void: ok
  use(f());   //# call_argument: compile-time error
  use(f() as Object);  //# call_as: ok
  void y = f();   //# call_void_init: ok
  dynamic z = f();  //# call_dynamic_init: compile-time error
  f() is Object;   //# call_is: compile-time error
  throw f();   //# call_throw: compile-time error
  <void>[f()];   //# call_literal_void_list_init: ok
  <Object>[f()];   //# call_literal_list_init: compile-time error
  var m1 = <int, void>{4: f() };   //# call_literal_map_value_init: ok
  var m2 = <void, int>{ f(): 4};   //# call_literal_map_key_init: ok
  var m3 = <dynamic, dynamic>{4: f() };  //# call_literal_map_value_init2: compile-time error
  var m4 = <dynamic, dynamic>{ f(): 4};  //# call_literal_map_key_init2: compile-time error
  f() ?? 499;  //# call_null_equals1: compile-time error
  null ?? f();  //# call_null_equals2: ok
  return f();   //# call_return: compile-time error
  while (f()) {};  //# call_while: compile-time error
  do {} while (f());  //# call_do_while: compile-time error
  for (var v in f()) {}   //# call_for_in: compile-time error
  f().toString();  //# call_toString: compile-time error
  f()?.toString();  //# call_null_dot: compile-time error
  f()..toString();  //# call_cascade: compile-time error
  if (f()) {}; //# call_conditional_stmt: compile-time error
  !f(); //# call_boolean_negation: compile-time error
  f() && true; //# call_boolean_and_left: compile-time error
  true && f(); //# call_boolean_and_right: compile-time error
  f() || true; //# call_boolean_or_left: compile-time error
  true || f(); //# call_boolean_or_right: compile-time error
  f() == 3; //# call_equals_left: compile-time error
  3 == f(); //# call_equals_right: compile-time error
  identical(3, f()); //# call_identical: compile-time error
  3 + f(); //# call_addition: compile-time error
  3 * f(); //# call_multiplication: compile-time error
  -f(); //# call_negation: compile-time error
  f()(3); //# call_use_as_function: compile-time error
  "hello${f()}"; //# call_use_in_string_interpolation: compile-time error
  f() ??= 3; //# call_use_in_conditional_assignment_left: compile-/# local_boolean_and_left: compile-time error
  true && x; //# local_boolean_and_right: compile-time error
  x || true; //# local_boolean_or_left: compile-ti_dynamic: ok
}

Object testVoidFinalLocal() {
  final void x = null;
  x = 42;   //# final_local_assign: compile-time error
  x;  //# final_local_stmt: ok
  true ? x : x;  //# final_local_conditional: ok
  for (x; false; x) {}   //# final_local_for: ok
  useAsVoid(x); //# final_local_argument_void: ok
  use(x);   //# final_local_argument: compile-time error
  use(x as Object);  //# final_local_as: ok
  void y = x;   //# final_local_void_init: ok
  dynamic z = x;  //# final_local_dynamic_init: compile-time erompile-time error
  for (var v in true ? x : 499) {}   //# conditional_for_in: compile-time error
}

dynamic testVoidConditionalDynamic() {
  void x;
  return true ? x : x;   //# conditional_return_dynamic: ok
  return true ? 499 : x;   //# conditional2_return_dynamic: ok
  return true ? x : 499;   //# conditional3_return_dynamic: ok
}

class A<T> {
  T x;

  void foo() {}
}

class B implements A<void> {
  void x;

  int foo() => 499;

  void forInTest() {
    for (x in <void>[]) {}  //# instance2_for_in2: ok
    for (x in [1, 2]) {}  //# instance2_for_in3: ok
  }
}

class C implements A<void> {
  void get x => null;
  set x(void y) {}

  void foo() {}

  void forInTest() {
    for (x in <void>[]) {}  //# instance3_for_in2: ok
    for (x in [1, 2]) {}  //# instance3_for_in3: ok
  }
}

Object testInstanceField() {
  A<void> a = new A<void>();
  a.x = 499;  //# field_assign: ok
  a.x;  //# instance_stmt: ok
  true ? a.x : a.x;  //# instance_conditional: ok
  for (a.x; false; a.x) {}   //# instance_for: ok
  useAsVoid(a.x); //# instance_argument_void: ok
  use(a.x);   //# instance_argument: compile-time error
  use(a.x as Object);  //# instance_as: ok
  void y = a.x;   //# instance_void_init: ok
  dynamic z = a.x;  //# instance_dynamic_init: compile-time error
  a.x is Object;   //# instance_is: compile-time error
  throwc.x) {}   //# instance3_for: ok
  useAsVoid(c.x); //# instance3_argument_void: ok
  use(c.x);   //# instansVoid((x)); //# paren_argument_void: ok
  use((x));   //# paren_argument: compile-time error
  use((x) as Object);  //# paren_as: ok
  void y = (x);   //# paren_void_init: ok
  dynamic z = (x);  //# paren_dynamic_init: compile-time error
  (x) is Object;   //# paren_is: compile-time error
  throw (x);   //# paren_throw: compile-time error
  <void>[(x)];   //# paren_literal_void_list_init: ok
  <Object>[(x)];   //# paren_literal_list_init: compile-time error
  var m1 = <int, void>{4: (x) };   //# paren_literal_map_value_init: ok
  var m2 = <void, int>{ (x): 4};   //# paren_literal_map_key_init: ok
  var m3 = <dynamic, dynamic>{4: (x) };  //# paren_literal_map_value_init2: compile-time error
  var m4 = <dynamic, dynamic>{ (x): 4};  //# paren_literal_map_key_init2: compile-time error
  (x) ?? 499;  //# paren_null_equals1: compile-time error
  null ?? (x);  //# paren_null_equals2: ok
  return (x);   //# paren_return: compile-time error
  while ((x)) {};  //# paren_while: compile-time error
  do {} while ((x));  //# paren_do_while: compile-time error
  for (var v in (x)) {}   //# paren_for_in: compile-time error
  (x).toString();  //# paren_toString: compile-time error
  (x)?.toString();  //# paren_null_dot: compile-timen_multiplication: compile-time error
  -(x); //# paren_negation: compile-time error
  (x)(3); //# paren_use_as_function: compile-time error
  "hello${(x)}"; //# paren_use_in_string_interpolation: compile-time error
  (xompile-time error
  Object xx;  xx ??= (x); //# paren_use_in_conditional_assignment_right: compile-time error
  var ll = <int>[3]; ll[(x)]; //# paren_use_in_list_subscript: compile-time error
  var mm = <void, void>{}; mm[(x)]; //# paren_use_in_map_lookup: compile-time error
}

dx);   //# paren_return_dynamic: ok
}

void testReturnToVoid(void x, void f()) {
  void y;
  final void z == new A<vorn x;   /void: ok
  return f